workflow:
  rules:
    - changes:
        - backend/**/*
        - frontend/**/*
        - monitoring/**/*
        - deployment/**/*
        - go.mod
        - go.sum
        - .gitlab-ci.yml
      when: always

    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      when: always

stages:
  - build
  - security
  - test
  - deploy
  - cleanup

variables:
  DOCKER_BUILDKIT: "1"
  DOCKER_CLI_IMAGE: docker:cli

  GOLANG_IMAGE: golang:alpine
  POSTGRES_IMAGE: postgres:17-alpine
  REDIS_IMAGE: redis:alpine
  GOLANGCI_LINT_IMAGE: golangci/golangci-lint:latest-alpine
  ALPINE_IMAGE: alpine:latest
  GOSEC_IMAGE: securego/gosec:latest
  TRIVY_IMAGE: aquasec/trivy:latest

  POSTGRES_DB: test_board
  POSTGRES_USER: test_user
  POSTGRES_PASSWORD: test_password
  REDIS_PASSWORD: "test_password"

.docker-login: &docker_login
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin

# Build stage
build:backend:
  stage: build
  image: $DOCKER_CLI_IMAGE
  <<: *docker_login
  script:
    - docker pull "$CI_REGISTRY_IMAGE/backend:latest" || true
    - |
      docker build \
        --cache-from "$CI_REGISTRY_IMAGE/backend:latest" \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        -t "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA" \
        -t "$CI_REGISTRY_IMAGE/backend:latest" \
        -f backend/Dockerfile \
        backend/
    - docker push "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
    - docker push "$CI_REGISTRY_IMAGE/backend:latest"
  rules:
    - changes:
        - backend/**/*
        - go.mod
        - go.sum
        - deployment/docker/**/*
      when: always

build:cleanup:
  stage: build
  image: $GOLANG_IMAGE
  script:
    - cd backend
    - GOOS=linux GOARCH=amd64 go build -o bin/ctfboard-cleanup ./cmd/cleanup
  artifacts:
    paths:
      - backend/bin/ctfboard-cleanup
    expire_in: 1 hour
  rules:
    - changes:
        - backend/cmd/cleanup/**/*
        - backend/internal/**/*
        - deployment/cron-jobs/**/*
        - .gitlab-ci.yml
      when: always

# Security stage

# Lint job
lint:backend:
  stage: security
  image: $GOLANGCI_LINT_IMAGE
  variables:
    CGO_ENABLED: "0"
  script:
    - cd backend
    - go mod download
    - golangci-lint run -v --timeout 10m
  rules:
    - changes:
        - backend/**/*
        - go.mod
        - go.sum
      when: always

# Security code job
security:code:
  stage: security
  image:
    name: $GOSEC_IMAGE
    entrypoint: [""]
  script:
    - cd backend
    - go mod download
    - gosec ./...
  rules:
    - changes:
        - backend/**/*
        - go.mod
        - go.sum
      when: always

# Security container job
security:container:
  stage: security
  image:
    name: $TRIVY_IMAGE
    entrypoint: [""]
  variables:
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
  script:
    - trivy image --exit-code 0 --severity HIGH,CRITICAL "$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA"
  rules:
    - changes:
        - backend/**/*
        - go.mod
        - go.sum
        - deployment/docker/**/*
      when: always

# Test stage
test:backend:
  stage: test
  image: $GOLANG_IMAGE
  services:
    - name: $POSTGRES_IMAGE
      alias: postgres-test
      variables:
        POSTGRES_DB: $POSTGRES_DB
        POSTGRES_USER: $POSTGRES_USER
        POSTGRES_PASSWORD: $POSTGRES_PASSWORD
    - name: $REDIS_IMAGE
      alias: redis-test
      variables:
        REDIS_PASSWORD: $REDIS_PASSWORD

  variables:
    POSTGRES_HOST: postgres-test
    POSTGRES_PORT: "5432"
    REDIS_HOST: redis-test
    REDIS_PORT: "6379"
    JWT_ACCESS_SECRET: test-access-secret-key-for-ci
    JWT_REFRESH_SECRET: test-refresh-secret-key-for-ci
    APP_NAME: CTFBoard
    APP_VERSION: 1.0.0
    CHI_MODE: test
    LOG_LEVEL: info
    BACKEND_PORT: "8080"
    MIGRATIONS_PATH: migrations
    CGO_ENABLED: "1"
  before_script:
    - apk add --no-cache build-base git netcat-openbsd postgresql-client

    - |
      echo "Waiting for PostgreSQL..."
      for i in $(seq 1 30); do
        pg_isready -h postgres-test -p 5432 -U $POSTGRES_USER && echo "PostgreSQL is ready!" && break
        echo "Waiting..."
        sleep 2
      done

    - |
      echo "Waiting for Redis..."
      for i in $(seq 1 10); do
        nc -z redis-test 6379 && echo "Redis is ready!" && break
        echo "Waiting..."
        sleep 1
      done

    - cd backend
    - go mod download
  script:
    - go test ./... -v -race
  rules:
    - changes:
        - backend/**/*
        - go.mod
        - go.sum
      when: always

# Deploy stage
deploy:
  stage: deploy
  image: $ALPINE_IMAGE
  before_script:
    - apk add --no-cache openssh-client curl
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H "$DEPLOY_SERVER_IP" >> ~/.ssh/known_hosts
  script:
    - |
      ssh -o StrictHostKeyChecking=accept-new $DEPLOY_USER@$DEPLOY_SERVER_IP "bash -s" << EOF
      set -e

      trap 'docker logout 2>/dev/null; rm -f ~/.docker/config.json' EXIT

      cd ~/ctfboard

      git fetch origin main
      git reset --hard origin/main

      echo "$CI_REGISTRY_PASSWORD" | docker login "$CI_REGISTRY" -u "$CI_REGISTRY_USER" --password-stdin

      sed -i '/^BACKEND_IMAGE=/d' .env || true
      echo "BACKEND_IMAGE=$CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA" >> .env

      docker compose --env-file .env -f deployment/docker/docker-compose.yml pull
      docker compose --env-file .env -f deployment/docker/docker-compose.yml up -d

      echo "Waiting for backend..."
      for i in {1..30}; do
        if curl -sf http://localhost:8090/health > /dev/null 2>&1; then
          echo "Backend is healthy!"
          break
        fi
        if [ \$i -eq 30 ]; then
          echo "Backend failed health check!"
          docker logs backend --tail 50
          exit 1
        fi
        sleep 2
      done

      EOF
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  environment:
    name: production
    url: https://ctfleague.ru

deploy:cron:
  stage: deploy
  image: $ALPINE_IMAGE
  needs: 
    - job: build:cleanup
      artifacts: true
  before_script:
    - apk add --no-cache openssh-client
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H "$DEPLOY_SERVER_IP" >> ~/.ssh/known_hosts
  script:
    - |
      BIN_SRC="backend/bin/ctfboard-cleanup"
      CRON_SRC="deployment/cron-jobs/cleanup-cron"
      BIN_DEST="/usr/local/bin/ctfboard-cleanup"
      CRON_DEST="/etc/cron.d/ctfboard-cleanup"

      echo "Deploying cleanup tool to $DEPLOY_USER@$DEPLOY_SERVER_IP..."

      scp -p "$BIN_SRC" "$DEPLOY_USER@$DEPLOY_SERVER_IP:/tmp/ctfboard-cleanup.bin"
      scp -p "$CRON_SRC" "$DEPLOY_USER@$DEPLOY_SERVER_IP:/tmp/ctfboard-cleanup.cron"

      ssh "$DEPLOY_USER@$DEPLOY_SERVER_IP" "bash -s" << 'EOF'
        set -e
        
        sudo mv /tmp/ctfboard-cleanup.bin /usr/local/bin/ctfboard-cleanup
        sudo chmod +x /usr/local/bin/ctfboard-cleanup
        sudo chown root:root /usr/local/bin/ctfboard-cleanup
        
        sudo mv /tmp/ctfboard-cleanup.cron /etc/cron.d/ctfboard-cleanup
        sudo chown root:root /etc/cron.d/ctfboard-cleanup
        sudo chmod 644 /etc/cron.d/ctfboard-cleanup
        
        sudo sed -i -e '$a\' /etc/cron.d/ctfboard-cleanup

        sudo systemctl reload cron 2>/dev/null || sudo systemctl restart cron
        
        echo "Cron deployment complete."
      EOF
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - backend/cmd/cleanup/**/*
        - backend/internal/**/*
        - deployment/cron-jobs/**/*
        - .gitlab-ci.yml
  environment:
    name: production
