// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"

	"github.com/skr1ms/CTFBoard/internal/entity"
	"github.com/skr1ms/CTFBoard/internal/repo"
	mock "github.com/stretchr/testify/mock"
)

// NewMockBackupRepository creates a new instance of MockBackupRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBackupRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBackupRepository {
	mock := &MockBackupRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBackupRepository is an autogenerated mock type for the BackupRepository type
type MockBackupRepository struct {
	mock.Mock
}

type MockBackupRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBackupRepository) EXPECT() *MockBackupRepository_Expecter {
	return &MockBackupRepository_Expecter{mock: &_m.Mock}
}

// EraseAllTablesTx provides a mock function for the type MockBackupRepository
func (_mock *MockBackupRepository) EraseAllTablesTx(ctx context.Context, tx repo.Transaction) error {
	ret := _mock.Called(ctx, tx)

	if len(ret) == 0 {
		panic("no return value specified for EraseAllTablesTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.Transaction) error); ok {
		r0 = returnFunc(ctx, tx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBackupRepository_EraseAllTablesTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EraseAllTablesTx'
type MockBackupRepository_EraseAllTablesTx_Call struct {
	*mock.Call
}

// EraseAllTablesTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repo.Transaction
func (_e *MockBackupRepository_Expecter) EraseAllTablesTx(ctx interface{}, tx interface{}) *MockBackupRepository_EraseAllTablesTx_Call {
	return &MockBackupRepository_EraseAllTablesTx_Call{Call: _e.mock.On("EraseAllTablesTx", ctx, tx)}
}

func (_c *MockBackupRepository_EraseAllTablesTx_Call) Run(run func(ctx context.Context, tx repo.Transaction)) *MockBackupRepository_EraseAllTablesTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.Transaction
		if args[1] != nil {
			arg1 = args[1].(repo.Transaction)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBackupRepository_EraseAllTablesTx_Call) Return(err error) *MockBackupRepository_EraseAllTablesTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBackupRepository_EraseAllTablesTx_Call) RunAndReturn(run func(ctx context.Context, tx repo.Transaction) error) *MockBackupRepository_EraseAllTablesTx_Call {
	_c.Call.Return(run)
	return _c
}

// ImportAwardsTx provides a mock function for the type MockBackupRepository
func (_mock *MockBackupRepository) ImportAwardsTx(ctx context.Context, tx repo.Transaction, data *entity.BackupData) error {
	ret := _mock.Called(ctx, tx, data)

	if len(ret) == 0 {
		panic("no return value specified for ImportAwardsTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.Transaction, *entity.BackupData) error); ok {
		r0 = returnFunc(ctx, tx, data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBackupRepository_ImportAwardsTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportAwardsTx'
type MockBackupRepository_ImportAwardsTx_Call struct {
	*mock.Call
}

// ImportAwardsTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repo.Transaction
//   - data *entity.BackupData
func (_e *MockBackupRepository_Expecter) ImportAwardsTx(ctx interface{}, tx interface{}, data interface{}) *MockBackupRepository_ImportAwardsTx_Call {
	return &MockBackupRepository_ImportAwardsTx_Call{Call: _e.mock.On("ImportAwardsTx", ctx, tx, data)}
}

func (_c *MockBackupRepository_ImportAwardsTx_Call) Run(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData)) *MockBackupRepository_ImportAwardsTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.Transaction
		if args[1] != nil {
			arg1 = args[1].(repo.Transaction)
		}
		var arg2 *entity.BackupData
		if args[2] != nil {
			arg2 = args[2].(*entity.BackupData)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBackupRepository_ImportAwardsTx_Call) Return(err error) *MockBackupRepository_ImportAwardsTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBackupRepository_ImportAwardsTx_Call) RunAndReturn(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData) error) *MockBackupRepository_ImportAwardsTx_Call {
	_c.Call.Return(run)
	return _c
}

// ImportChallengesTx provides a mock function for the type MockBackupRepository
func (_mock *MockBackupRepository) ImportChallengesTx(ctx context.Context, tx repo.Transaction, data *entity.BackupData) error {
	ret := _mock.Called(ctx, tx, data)

	if len(ret) == 0 {
		panic("no return value specified for ImportChallengesTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.Transaction, *entity.BackupData) error); ok {
		r0 = returnFunc(ctx, tx, data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBackupRepository_ImportChallengesTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportChallengesTx'
type MockBackupRepository_ImportChallengesTx_Call struct {
	*mock.Call
}

// ImportChallengesTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repo.Transaction
//   - data *entity.BackupData
func (_e *MockBackupRepository_Expecter) ImportChallengesTx(ctx interface{}, tx interface{}, data interface{}) *MockBackupRepository_ImportChallengesTx_Call {
	return &MockBackupRepository_ImportChallengesTx_Call{Call: _e.mock.On("ImportChallengesTx", ctx, tx, data)}
}

func (_c *MockBackupRepository_ImportChallengesTx_Call) Run(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData)) *MockBackupRepository_ImportChallengesTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.Transaction
		if args[1] != nil {
			arg1 = args[1].(repo.Transaction)
		}
		var arg2 *entity.BackupData
		if args[2] != nil {
			arg2 = args[2].(*entity.BackupData)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBackupRepository_ImportChallengesTx_Call) Return(err error) *MockBackupRepository_ImportChallengesTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBackupRepository_ImportChallengesTx_Call) RunAndReturn(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData) error) *MockBackupRepository_ImportChallengesTx_Call {
	_c.Call.Return(run)
	return _c
}

// ImportCompetitionTx provides a mock function for the type MockBackupRepository
func (_mock *MockBackupRepository) ImportCompetitionTx(ctx context.Context, tx repo.Transaction, comp *entity.Competition) error {
	ret := _mock.Called(ctx, tx, comp)

	if len(ret) == 0 {
		panic("no return value specified for ImportCompetitionTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.Transaction, *entity.Competition) error); ok {
		r0 = returnFunc(ctx, tx, comp)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBackupRepository_ImportCompetitionTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportCompetitionTx'
type MockBackupRepository_ImportCompetitionTx_Call struct {
	*mock.Call
}

// ImportCompetitionTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repo.Transaction
//   - comp *entity.Competition
func (_e *MockBackupRepository_Expecter) ImportCompetitionTx(ctx interface{}, tx interface{}, comp interface{}) *MockBackupRepository_ImportCompetitionTx_Call {
	return &MockBackupRepository_ImportCompetitionTx_Call{Call: _e.mock.On("ImportCompetitionTx", ctx, tx, comp)}
}

func (_c *MockBackupRepository_ImportCompetitionTx_Call) Run(run func(ctx context.Context, tx repo.Transaction, comp *entity.Competition)) *MockBackupRepository_ImportCompetitionTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.Transaction
		if args[1] != nil {
			arg1 = args[1].(repo.Transaction)
		}
		var arg2 *entity.Competition
		if args[2] != nil {
			arg2 = args[2].(*entity.Competition)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBackupRepository_ImportCompetitionTx_Call) Return(err error) *MockBackupRepository_ImportCompetitionTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBackupRepository_ImportCompetitionTx_Call) RunAndReturn(run func(ctx context.Context, tx repo.Transaction, comp *entity.Competition) error) *MockBackupRepository_ImportCompetitionTx_Call {
	_c.Call.Return(run)
	return _c
}

// ImportFileMetadataTx provides a mock function for the type MockBackupRepository
func (_mock *MockBackupRepository) ImportFileMetadataTx(ctx context.Context, tx repo.Transaction, data *entity.BackupData) error {
	ret := _mock.Called(ctx, tx, data)

	if len(ret) == 0 {
		panic("no return value specified for ImportFileMetadataTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.Transaction, *entity.BackupData) error); ok {
		r0 = returnFunc(ctx, tx, data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBackupRepository_ImportFileMetadataTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportFileMetadataTx'
type MockBackupRepository_ImportFileMetadataTx_Call struct {
	*mock.Call
}

// ImportFileMetadataTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repo.Transaction
//   - data *entity.BackupData
func (_e *MockBackupRepository_Expecter) ImportFileMetadataTx(ctx interface{}, tx interface{}, data interface{}) *MockBackupRepository_ImportFileMetadataTx_Call {
	return &MockBackupRepository_ImportFileMetadataTx_Call{Call: _e.mock.On("ImportFileMetadataTx", ctx, tx, data)}
}

func (_c *MockBackupRepository_ImportFileMetadataTx_Call) Run(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData)) *MockBackupRepository_ImportFileMetadataTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.Transaction
		if args[1] != nil {
			arg1 = args[1].(repo.Transaction)
		}
		var arg2 *entity.BackupData
		if args[2] != nil {
			arg2 = args[2].(*entity.BackupData)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBackupRepository_ImportFileMetadataTx_Call) Return(err error) *MockBackupRepository_ImportFileMetadataTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBackupRepository_ImportFileMetadataTx_Call) RunAndReturn(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData) error) *MockBackupRepository_ImportFileMetadataTx_Call {
	_c.Call.Return(run)
	return _c
}

// ImportSolvesTx provides a mock function for the type MockBackupRepository
func (_mock *MockBackupRepository) ImportSolvesTx(ctx context.Context, tx repo.Transaction, data *entity.BackupData) error {
	ret := _mock.Called(ctx, tx, data)

	if len(ret) == 0 {
		panic("no return value specified for ImportSolvesTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.Transaction, *entity.BackupData) error); ok {
		r0 = returnFunc(ctx, tx, data)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBackupRepository_ImportSolvesTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportSolvesTx'
type MockBackupRepository_ImportSolvesTx_Call struct {
	*mock.Call
}

// ImportSolvesTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repo.Transaction
//   - data *entity.BackupData
func (_e *MockBackupRepository_Expecter) ImportSolvesTx(ctx interface{}, tx interface{}, data interface{}) *MockBackupRepository_ImportSolvesTx_Call {
	return &MockBackupRepository_ImportSolvesTx_Call{Call: _e.mock.On("ImportSolvesTx", ctx, tx, data)}
}

func (_c *MockBackupRepository_ImportSolvesTx_Call) Run(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData)) *MockBackupRepository_ImportSolvesTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.Transaction
		if args[1] != nil {
			arg1 = args[1].(repo.Transaction)
		}
		var arg2 *entity.BackupData
		if args[2] != nil {
			arg2 = args[2].(*entity.BackupData)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockBackupRepository_ImportSolvesTx_Call) Return(err error) *MockBackupRepository_ImportSolvesTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBackupRepository_ImportSolvesTx_Call) RunAndReturn(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData) error) *MockBackupRepository_ImportSolvesTx_Call {
	_c.Call.Return(run)
	return _c
}

// ImportTeamsTx provides a mock function for the type MockBackupRepository
func (_mock *MockBackupRepository) ImportTeamsTx(ctx context.Context, tx repo.Transaction, data *entity.BackupData, opts entity.ImportOptions) error {
	ret := _mock.Called(ctx, tx, data, opts)

	if len(ret) == 0 {
		panic("no return value specified for ImportTeamsTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.Transaction, *entity.BackupData, entity.ImportOptions) error); ok {
		r0 = returnFunc(ctx, tx, data, opts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBackupRepository_ImportTeamsTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportTeamsTx'
type MockBackupRepository_ImportTeamsTx_Call struct {
	*mock.Call
}

// ImportTeamsTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repo.Transaction
//   - data *entity.BackupData
//   - opts entity.ImportOptions
func (_e *MockBackupRepository_Expecter) ImportTeamsTx(ctx interface{}, tx interface{}, data interface{}, opts interface{}) *MockBackupRepository_ImportTeamsTx_Call {
	return &MockBackupRepository_ImportTeamsTx_Call{Call: _e.mock.On("ImportTeamsTx", ctx, tx, data, opts)}
}

func (_c *MockBackupRepository_ImportTeamsTx_Call) Run(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData, opts entity.ImportOptions)) *MockBackupRepository_ImportTeamsTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.Transaction
		if args[1] != nil {
			arg1 = args[1].(repo.Transaction)
		}
		var arg2 *entity.BackupData
		if args[2] != nil {
			arg2 = args[2].(*entity.BackupData)
		}
		var arg3 entity.ImportOptions
		if args[3] != nil {
			arg3 = args[3].(entity.ImportOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockBackupRepository_ImportTeamsTx_Call) Return(err error) *MockBackupRepository_ImportTeamsTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBackupRepository_ImportTeamsTx_Call) RunAndReturn(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData, opts entity.ImportOptions) error) *MockBackupRepository_ImportTeamsTx_Call {
	_c.Call.Return(run)
	return _c
}

// ImportUsersTx provides a mock function for the type MockBackupRepository
func (_mock *MockBackupRepository) ImportUsersTx(ctx context.Context, tx repo.Transaction, data *entity.BackupData, opts entity.ImportOptions) error {
	ret := _mock.Called(ctx, tx, data, opts)

	if len(ret) == 0 {
		panic("no return value specified for ImportUsersTx")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, repo.Transaction, *entity.BackupData, entity.ImportOptions) error); ok {
		r0 = returnFunc(ctx, tx, data, opts)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBackupRepository_ImportUsersTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ImportUsersTx'
type MockBackupRepository_ImportUsersTx_Call struct {
	*mock.Call
}

// ImportUsersTx is a helper method to define mock.On call
//   - ctx context.Context
//   - tx repo.Transaction
//   - data *entity.BackupData
//   - opts entity.ImportOptions
func (_e *MockBackupRepository_Expecter) ImportUsersTx(ctx interface{}, tx interface{}, data interface{}, opts interface{}) *MockBackupRepository_ImportUsersTx_Call {
	return &MockBackupRepository_ImportUsersTx_Call{Call: _e.mock.On("ImportUsersTx", ctx, tx, data, opts)}
}

func (_c *MockBackupRepository_ImportUsersTx_Call) Run(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData, opts entity.ImportOptions)) *MockBackupRepository_ImportUsersTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 repo.Transaction
		if args[1] != nil {
			arg1 = args[1].(repo.Transaction)
		}
		var arg2 *entity.BackupData
		if args[2] != nil {
			arg2 = args[2].(*entity.BackupData)
		}
		var arg3 entity.ImportOptions
		if args[3] != nil {
			arg3 = args[3].(entity.ImportOptions)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockBackupRepository_ImportUsersTx_Call) Return(err error) *MockBackupRepository_ImportUsersTx_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBackupRepository_ImportUsersTx_Call) RunAndReturn(run func(ctx context.Context, tx repo.Transaction, data *entity.BackupData, opts entity.ImportOptions) error) *MockBackupRepository_ImportUsersTx_Call {
	_c.Call.Return(run)
	return _c
}
