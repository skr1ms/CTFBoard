// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: statistics.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countChallenges = `-- name: CountChallenges :one
SELECT COUNT(*)::int FROM challenges
`

func (q *Queries) CountChallenges(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countChallenges)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countSolves = `-- name: CountSolves :one
SELECT COUNT(*)::int FROM solves
`

func (q *Queries) CountSolves(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countSolves)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countTeams = `-- name: CountTeams :one
SELECT COUNT(*)::int FROM teams WHERE deleted_at IS NULL
`

func (q *Queries) CountTeams(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countTeams)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*)::int FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const getChallengeDetailChallenge = `-- name: GetChallengeDetailChallenge :one
SELECT c.id, c.title, c.category, c.points, c.solve_count,
    (SELECT COUNT(*)::int FROM teams WHERE deleted_at IS NULL AND is_banned = false AND is_hidden = false) AS total_teams
FROM challenges c
WHERE c.id = $1
`

type GetChallengeDetailChallengeRow struct {
	ID         uuid.UUID `json:"id"`
	Title      string    `json:"title"`
	Category   *string   `json:"category"`
	Points     *int32    `json:"points"`
	SolveCount int32     `json:"solve_count"`
	TotalTeams int32     `json:"total_teams"`
}

func (q *Queries) GetChallengeDetailChallenge(ctx context.Context, id uuid.UUID) (GetChallengeDetailChallengeRow, error) {
	row := q.db.QueryRow(ctx, getChallengeDetailChallenge, id)
	var i GetChallengeDetailChallengeRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Category,
		&i.Points,
		&i.SolveCount,
		&i.TotalTeams,
	)
	return i, err
}

const getChallengeDetailSolves = `-- name: GetChallengeDetailSolves :many
SELECT s.team_id, t.name AS team_name, s.solved_at
FROM solves s
JOIN teams t ON t.id = s.team_id
WHERE s.challenge_id = $1 AND t.deleted_at IS NULL AND t.is_banned = false AND t.is_hidden = false
ORDER BY s.solved_at ASC
`

type GetChallengeDetailSolvesRow struct {
	TeamID   uuid.UUID  `json:"team_id"`
	TeamName string     `json:"team_name"`
	SolvedAt *time.Time `json:"solved_at"`
}

func (q *Queries) GetChallengeDetailSolves(ctx context.Context, challengeID uuid.UUID) ([]GetChallengeDetailSolvesRow, error) {
	rows, err := q.db.Query(ctx, getChallengeDetailSolves, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChallengeDetailSolvesRow
	for rows.Next() {
		var i GetChallengeDetailSolvesRow
		if err := rows.Scan(&i.TeamID, &i.TeamName, &i.SolvedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChallengeStats = `-- name: GetChallengeStats :many
SELECT id, title, category, points, solve_count
FROM challenges
ORDER BY solve_count DESC
`

type GetChallengeStatsRow struct {
	ID         uuid.UUID `json:"id"`
	Title      string    `json:"title"`
	Category   *string   `json:"category"`
	Points     *int32    `json:"points"`
	SolveCount int32     `json:"solve_count"`
}

func (q *Queries) GetChallengeStats(ctx context.Context) ([]GetChallengeStatsRow, error) {
	rows, err := q.db.Query(ctx, getChallengeStats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetChallengeStatsRow
	for rows.Next() {
		var i GetChallengeStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Category,
			&i.Points,
			&i.SolveCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoreboardHistory = `-- name: GetScoreboardHistory :many
WITH top_teams AS (
    SELECT t.id, t.name
    FROM teams t
    LEFT JOIN solves s ON s.team_id = t.id
    LEFT JOIN challenges c ON s.challenge_id = c.id
    LEFT JOIN awards a ON a.team_id = t.id
    WHERE t.deleted_at IS NULL
    GROUP BY t.id
    ORDER BY COALESCE(SUM(c.points), 0) + COALESCE(SUM(a.value), 0) DESC
    LIMIT $1
),
events AS (
    SELECT s.team_id, s.solved_at AS event_time, c.points AS delta
    FROM solves s
    JOIN challenges c ON s.challenge_id = c.id
    WHERE s.team_id IN (SELECT id FROM top_teams)
    UNION ALL
    SELECT a.team_id, a.created_at AS event_time, a.value AS delta
    FROM awards a
    WHERE a.team_id IN (SELECT id FROM top_teams)
)
SELECT e.team_id, tt.name AS team_name, SUM(e.delta) OVER (PARTITION BY e.team_id ORDER BY e.event_time)::int AS points, e.event_time AS timestamp
FROM events e
JOIN top_teams tt ON e.team_id = tt.id
ORDER BY e.team_id, e.event_time
`

type GetScoreboardHistoryRow struct {
	TeamID    uuid.UUID  `json:"team_id"`
	TeamName  string     `json:"team_name"`
	Points    int32      `json:"points"`
	Timestamp *time.Time `json:"timestamp"`
}

func (q *Queries) GetScoreboardHistory(ctx context.Context, limit int32) ([]GetScoreboardHistoryRow, error) {
	rows, err := q.db.Query(ctx, getScoreboardHistory, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoreboardHistoryRow
	for rows.Next() {
		var i GetScoreboardHistoryRow
		if err := rows.Scan(
			&i.TeamID,
			&i.TeamName,
			&i.Points,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
