// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: submissions.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countAllSubmissions = `-- name: CountAllSubmissions :one
SELECT COUNT(*) FROM submissions
`

func (q *Queries) CountAllSubmissions(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllSubmissions)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFailedSubmissionsByIP = `-- name: CountFailedSubmissionsByIP :one
SELECT COUNT(*) FROM submissions WHERE ip = $1 AND is_correct = FALSE AND created_at > $2
`

type CountFailedSubmissionsByIPParams struct {
	Ip        *string    `json:"ip"`
	CreatedAt *time.Time `json:"created_at"`
}

func (q *Queries) CountFailedSubmissionsByIP(ctx context.Context, arg CountFailedSubmissionsByIPParams) (int64, error) {
	row := q.db.QueryRow(ctx, countFailedSubmissionsByIP, arg.Ip, arg.CreatedAt)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubmissionsByChallenge = `-- name: CountSubmissionsByChallenge :one
SELECT COUNT(*) FROM submissions WHERE challenge_id = $1
`

func (q *Queries) CountSubmissionsByChallenge(ctx context.Context, challengeID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSubmissionsByChallenge, challengeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubmissionsByTeam = `-- name: CountSubmissionsByTeam :one
SELECT COUNT(*) FROM submissions WHERE team_id = $1
`

func (q *Queries) CountSubmissionsByTeam(ctx context.Context, teamID *uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSubmissionsByTeam, teamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSubmissionsByUser = `-- name: CountSubmissionsByUser :one
SELECT COUNT(*) FROM submissions WHERE user_id = $1
`

func (q *Queries) CountSubmissionsByUser(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSubmissionsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSubmission = `-- name: CreateSubmission :exec
INSERT INTO submissions (id, user_id, team_id, challenge_id, submitted_flag, is_correct, ip, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateSubmissionParams struct {
	ID            uuid.UUID  `json:"id"`
	UserID        uuid.UUID  `json:"user_id"`
	TeamID        *uuid.UUID `json:"team_id"`
	ChallengeID   uuid.UUID  `json:"challenge_id"`
	SubmittedFlag string     `json:"submitted_flag"`
	IsCorrect     bool       `json:"is_correct"`
	Ip            *string    `json:"ip"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) error {
	_, err := q.db.Exec(ctx, createSubmission,
		arg.ID,
		arg.UserID,
		arg.TeamID,
		arg.ChallengeID,
		arg.SubmittedFlag,
		arg.IsCorrect,
		arg.Ip,
		arg.CreatedAt,
	)
	return err
}

const getAllSubmissions = `-- name: GetAllSubmissions :many
SELECT s.id, s.user_id, s.team_id, s.challenge_id, s.submitted_flag, s.is_correct, s.ip, s.created_at,
       u.username, COALESCE(t.name, '') AS team_name, c.title AS challenge_title, c.category AS challenge_category
FROM submissions s
JOIN users u ON u.id = s.user_id
LEFT JOIN teams t ON t.id = s.team_id
JOIN challenges c ON c.id = s.challenge_id
ORDER BY s.created_at DESC
LIMIT $1 OFFSET $2
`

type GetAllSubmissionsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllSubmissionsRow struct {
	ID                uuid.UUID  `json:"id"`
	UserID            uuid.UUID  `json:"user_id"`
	TeamID            *uuid.UUID `json:"team_id"`
	ChallengeID       uuid.UUID  `json:"challenge_id"`
	SubmittedFlag     string     `json:"submitted_flag"`
	IsCorrect         bool       `json:"is_correct"`
	Ip                *string    `json:"ip"`
	CreatedAt         *time.Time `json:"created_at"`
	Username          string     `json:"username"`
	TeamName          string     `json:"team_name"`
	ChallengeTitle    string     `json:"challenge_title"`
	ChallengeCategory *string    `json:"challenge_category"`
}

func (q *Queries) GetAllSubmissions(ctx context.Context, arg GetAllSubmissionsParams) ([]GetAllSubmissionsRow, error) {
	rows, err := q.db.Query(ctx, getAllSubmissions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSubmissionsRow
	for rows.Next() {
		var i GetAllSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.ChallengeID,
			&i.SubmittedFlag,
			&i.IsCorrect,
			&i.Ip,
			&i.CreatedAt,
			&i.Username,
			&i.TeamName,
			&i.ChallengeTitle,
			&i.ChallengeCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionStats = `-- name: GetSubmissionStats :one
SELECT 
    COUNT(*) AS total,
    COUNT(*) FILTER (WHERE is_correct = TRUE) AS correct,
    COUNT(*) FILTER (WHERE is_correct = FALSE) AS incorrect
FROM submissions
WHERE challenge_id = $1
`

type GetSubmissionStatsRow struct {
	Total     int64 `json:"total"`
	Correct   int64 `json:"correct"`
	Incorrect int64 `json:"incorrect"`
}

func (q *Queries) GetSubmissionStats(ctx context.Context, challengeID uuid.UUID) (GetSubmissionStatsRow, error) {
	row := q.db.QueryRow(ctx, getSubmissionStats, challengeID)
	var i GetSubmissionStatsRow
	err := row.Scan(&i.Total, &i.Correct, &i.Incorrect)
	return i, err
}

const getSubmissionsByChallenge = `-- name: GetSubmissionsByChallenge :many
SELECT s.id, s.user_id, s.team_id, s.challenge_id, s.submitted_flag, s.is_correct, s.ip, s.created_at,
       u.username, COALESCE(t.name, '') AS team_name
FROM submissions s
JOIN users u ON u.id = s.user_id
LEFT JOIN teams t ON t.id = s.team_id
WHERE s.challenge_id = $1
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type GetSubmissionsByChallengeParams struct {
	ChallengeID uuid.UUID `json:"challenge_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type GetSubmissionsByChallengeRow struct {
	ID            uuid.UUID  `json:"id"`
	UserID        uuid.UUID  `json:"user_id"`
	TeamID        *uuid.UUID `json:"team_id"`
	ChallengeID   uuid.UUID  `json:"challenge_id"`
	SubmittedFlag string     `json:"submitted_flag"`
	IsCorrect     bool       `json:"is_correct"`
	Ip            *string    `json:"ip"`
	CreatedAt     *time.Time `json:"created_at"`
	Username      string     `json:"username"`
	TeamName      string     `json:"team_name"`
}

func (q *Queries) GetSubmissionsByChallenge(ctx context.Context, arg GetSubmissionsByChallengeParams) ([]GetSubmissionsByChallengeRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByChallenge, arg.ChallengeID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByChallengeRow
	for rows.Next() {
		var i GetSubmissionsByChallengeRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.ChallengeID,
			&i.SubmittedFlag,
			&i.IsCorrect,
			&i.Ip,
			&i.CreatedAt,
			&i.Username,
			&i.TeamName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByTeam = `-- name: GetSubmissionsByTeam :many
SELECT s.id, s.user_id, s.team_id, s.challenge_id, s.submitted_flag, s.is_correct, s.ip, s.created_at,
       u.username, c.title AS challenge_title, c.category AS challenge_category
FROM submissions s
JOIN users u ON u.id = s.user_id
JOIN challenges c ON c.id = s.challenge_id
WHERE s.team_id = $1
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type GetSubmissionsByTeamParams struct {
	TeamID *uuid.UUID `json:"team_id"`
	Limit  int32      `json:"limit"`
	Offset int32      `json:"offset"`
}

type GetSubmissionsByTeamRow struct {
	ID                uuid.UUID  `json:"id"`
	UserID            uuid.UUID  `json:"user_id"`
	TeamID            *uuid.UUID `json:"team_id"`
	ChallengeID       uuid.UUID  `json:"challenge_id"`
	SubmittedFlag     string     `json:"submitted_flag"`
	IsCorrect         bool       `json:"is_correct"`
	Ip                *string    `json:"ip"`
	CreatedAt         *time.Time `json:"created_at"`
	Username          string     `json:"username"`
	ChallengeTitle    string     `json:"challenge_title"`
	ChallengeCategory *string    `json:"challenge_category"`
}

func (q *Queries) GetSubmissionsByTeam(ctx context.Context, arg GetSubmissionsByTeamParams) ([]GetSubmissionsByTeamRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByTeam, arg.TeamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByTeamRow
	for rows.Next() {
		var i GetSubmissionsByTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.ChallengeID,
			&i.SubmittedFlag,
			&i.IsCorrect,
			&i.Ip,
			&i.CreatedAt,
			&i.Username,
			&i.ChallengeTitle,
			&i.ChallengeCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubmissionsByUser = `-- name: GetSubmissionsByUser :many
SELECT s.id, s.user_id, s.team_id, s.challenge_id, s.submitted_flag, s.is_correct, s.ip, s.created_at,
       c.title AS challenge_title, c.category AS challenge_category
FROM submissions s
JOIN challenges c ON c.id = s.challenge_id
WHERE s.user_id = $1
ORDER BY s.created_at DESC
LIMIT $2 OFFSET $3
`

type GetSubmissionsByUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

type GetSubmissionsByUserRow struct {
	ID                uuid.UUID  `json:"id"`
	UserID            uuid.UUID  `json:"user_id"`
	TeamID            *uuid.UUID `json:"team_id"`
	ChallengeID       uuid.UUID  `json:"challenge_id"`
	SubmittedFlag     string     `json:"submitted_flag"`
	IsCorrect         bool       `json:"is_correct"`
	Ip                *string    `json:"ip"`
	CreatedAt         *time.Time `json:"created_at"`
	ChallengeTitle    string     `json:"challenge_title"`
	ChallengeCategory *string    `json:"challenge_category"`
}

func (q *Queries) GetSubmissionsByUser(ctx context.Context, arg GetSubmissionsByUserParams) ([]GetSubmissionsByUserRow, error) {
	rows, err := q.db.Query(ctx, getSubmissionsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubmissionsByUserRow
	for rows.Next() {
		var i GetSubmissionsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.ChallengeID,
			&i.SubmittedFlag,
			&i.IsCorrect,
			&i.Ip,
			&i.CreatedAt,
			&i.ChallengeTitle,
			&i.ChallengeCategory,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
