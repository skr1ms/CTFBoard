// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: fields.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createField = `-- name: CreateField :exec
INSERT INTO fields (id, name, field_type, entity_type, required, options, order_index, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateFieldParams struct {
	ID         uuid.UUID  `json:"id"`
	Name       string     `json:"name"`
	FieldType  string     `json:"field_type"`
	EntityType string     `json:"entity_type"`
	Required   *bool      `json:"required"`
	Options    []byte     `json:"options"`
	OrderIndex *int32     `json:"order_index"`
	CreatedAt  *time.Time `json:"created_at"`
}

func (q *Queries) CreateField(ctx context.Context, arg CreateFieldParams) error {
	_, err := q.db.Exec(ctx, createField,
		arg.ID,
		arg.Name,
		arg.FieldType,
		arg.EntityType,
		arg.Required,
		arg.Options,
		arg.OrderIndex,
		arg.CreatedAt,
	)
	return err
}

const deleteField = `-- name: DeleteField :exec
DELETE FROM fields WHERE id = $1
`

func (q *Queries) DeleteField(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteField, id)
	return err
}

const deleteFieldValuesByEntityID = `-- name: DeleteFieldValuesByEntityID :exec
DELETE FROM field_values WHERE entity_id = $1
`

func (q *Queries) DeleteFieldValuesByEntityID(ctx context.Context, entityID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFieldValuesByEntityID, entityID)
	return err
}

const getAllFields = `-- name: GetAllFields :many
SELECT id, name, field_type, entity_type, required, options, order_index, created_at
FROM fields ORDER BY entity_type, order_index, name
`

func (q *Queries) GetAllFields(ctx context.Context) ([]Field, error) {
	rows, err := q.db.Query(ctx, getAllFields)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Field
	for rows.Next() {
		var i Field
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FieldType,
			&i.EntityType,
			&i.Required,
			&i.Options,
			&i.OrderIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFieldByID = `-- name: GetFieldByID :one
SELECT id, name, field_type, entity_type, required, options, order_index, created_at
FROM fields WHERE id = $1
`

func (q *Queries) GetFieldByID(ctx context.Context, id uuid.UUID) (Field, error) {
	row := q.db.QueryRow(ctx, getFieldByID, id)
	var i Field
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.FieldType,
		&i.EntityType,
		&i.Required,
		&i.Options,
		&i.OrderIndex,
		&i.CreatedAt,
	)
	return i, err
}

const getFieldValuesByEntityID = `-- name: GetFieldValuesByEntityID :many
SELECT id, field_id, entity_id, value, created_at
FROM field_values WHERE entity_id = $1
`

func (q *Queries) GetFieldValuesByEntityID(ctx context.Context, entityID uuid.UUID) ([]FieldValue, error) {
	rows, err := q.db.Query(ctx, getFieldValuesByEntityID, entityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldValue
	for rows.Next() {
		var i FieldValue
		if err := rows.Scan(
			&i.ID,
			&i.FieldID,
			&i.EntityID,
			&i.Value,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFieldsByEntityType = `-- name: GetFieldsByEntityType :many
SELECT id, name, field_type, entity_type, required, options, order_index, created_at
FROM fields WHERE entity_type = $1 ORDER BY order_index, name
`

func (q *Queries) GetFieldsByEntityType(ctx context.Context, entityType string) ([]Field, error) {
	rows, err := q.db.Query(ctx, getFieldsByEntityType, entityType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Field
	for rows.Next() {
		var i Field
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.FieldType,
			&i.EntityType,
			&i.Required,
			&i.Options,
			&i.OrderIndex,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateField = `-- name: UpdateField :exec
UPDATE fields SET name = $2, field_type = $3, required = $4, options = $5, order_index = $6
WHERE id = $1
`

type UpdateFieldParams struct {
	ID         uuid.UUID `json:"id"`
	Name       string    `json:"name"`
	FieldType  string    `json:"field_type"`
	Required   *bool     `json:"required"`
	Options    []byte    `json:"options"`
	OrderIndex *int32    `json:"order_index"`
}

func (q *Queries) UpdateField(ctx context.Context, arg UpdateFieldParams) error {
	_, err := q.db.Exec(ctx, updateField,
		arg.ID,
		arg.Name,
		arg.FieldType,
		arg.Required,
		arg.Options,
		arg.OrderIndex,
	)
	return err
}

const upsertFieldValue = `-- name: UpsertFieldValue :exec
INSERT INTO field_values (id, field_id, entity_id, value, created_at)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (field_id, entity_id) DO UPDATE SET value = EXCLUDED.value
`

type UpsertFieldValueParams struct {
	ID        uuid.UUID  `json:"id"`
	FieldID   uuid.UUID  `json:"field_id"`
	EntityID  uuid.UUID  `json:"entity_id"`
	Value     string     `json:"value"`
	CreatedAt *time.Time `json:"created_at"`
}

func (q *Queries) UpsertFieldValue(ctx context.Context, arg UpsertFieldValueParams) error {
	_, err := q.db.Exec(ctx, upsertFieldValue,
		arg.ID,
		arg.FieldID,
		arg.EntityID,
		arg.Value,
		arg.CreatedAt,
	)
	return err
}
