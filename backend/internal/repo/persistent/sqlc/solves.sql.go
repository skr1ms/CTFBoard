// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: solves.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createSolve = `-- name: CreateSolve :exec
INSERT INTO solves (id, user_id, team_id, challenge_id, solved_at)
VALUES ($1, $2, $3, $4, $5)
`

type CreateSolveParams struct {
	ID          uuid.UUID  `json:"id"`
	UserID      uuid.UUID  `json:"user_id"`
	TeamID      uuid.UUID  `json:"team_id"`
	ChallengeID uuid.UUID  `json:"challenge_id"`
	SolvedAt    *time.Time `json:"solved_at"`
}

func (q *Queries) CreateSolve(ctx context.Context, arg CreateSolveParams) error {
	_, err := q.db.Exec(ctx, createSolve,
		arg.ID,
		arg.UserID,
		arg.TeamID,
		arg.ChallengeID,
		arg.SolvedAt,
	)
	return err
}

const deleteSolvesByTeamID = `-- name: DeleteSolvesByTeamID :exec
DELETE FROM solves WHERE team_id = $1
`

func (q *Queries) DeleteSolvesByTeamID(ctx context.Context, teamID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSolvesByTeamID, teamID)
	return err
}

const getAllSolves = `-- name: GetAllSolves :many
SELECT id, user_id, team_id, challenge_id, solved_at
FROM solves
ORDER BY solved_at ASC
`

func (q *Queries) GetAllSolves(ctx context.Context) ([]Solf, error) {
	rows, err := q.db.Query(ctx, getAllSolves)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Solf
	for rows.Next() {
		var i Solf
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.ChallengeID,
			&i.SolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstBlood = `-- name: GetFirstBlood :one
SELECT s.user_id, u.username, s.team_id, t.name AS team_name, s.solved_at
FROM solves s
JOIN users u ON u.id = s.user_id
JOIN teams t ON t.id = s.team_id
WHERE s.challenge_id = $1
ORDER BY s.solved_at ASC
LIMIT 1
`

type GetFirstBloodRow struct {
	UserID   uuid.UUID  `json:"user_id"`
	Username string     `json:"username"`
	TeamID   uuid.UUID  `json:"team_id"`
	TeamName string     `json:"team_name"`
	SolvedAt *time.Time `json:"solved_at"`
}

func (q *Queries) GetFirstBlood(ctx context.Context, challengeID uuid.UUID) (GetFirstBloodRow, error) {
	row := q.db.QueryRow(ctx, getFirstBlood, challengeID)
	var i GetFirstBloodRow
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.TeamID,
		&i.TeamName,
		&i.SolvedAt,
	)
	return i, err
}

const getScoreboard = `-- name: GetScoreboard :many
SELECT
    t.id AS team_id,
    t.name AS team_name,
    COALESCE(solve_points.points, 0) + COALESCE(award_points.total, 0) AS points,
    solve_points.last_solved AS solved_at
FROM teams t
LEFT JOIN (
    SELECT s.team_id, SUM(c.points)::int AS points, MAX(s.solved_at) AS last_solved
    FROM solves s
    JOIN challenges c ON c.id = s.challenge_id
    GROUP BY s.team_id
) solve_points ON solve_points.team_id = t.id
LEFT JOIN (
    SELECT team_id, SUM(value)::int AS total
    FROM awards
    GROUP BY team_id
) award_points ON award_points.team_id = t.id
WHERE t.is_banned = false AND t.is_hidden = false AND t.deleted_at IS NULL
ORDER BY points DESC, COALESCE(solve_points.last_solved, '9999-12-31'::timestamp) ASC
`

type GetScoreboardRow struct {
	TeamID   uuid.UUID   `json:"team_id"`
	TeamName string      `json:"team_name"`
	Points   int32       `json:"points"`
	SolvedAt interface{} `json:"solved_at"`
}

func (q *Queries) GetScoreboard(ctx context.Context) ([]GetScoreboardRow, error) {
	rows, err := q.db.Query(ctx, getScoreboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoreboardRow
	for rows.Next() {
		var i GetScoreboardRow
		if err := rows.Scan(
			&i.TeamID,
			&i.TeamName,
			&i.Points,
			&i.SolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoreboardFrozen = `-- name: GetScoreboardFrozen :many
SELECT
    t.id AS team_id,
    t.name AS team_name,
    COALESCE(solve_points.points, 0) + COALESCE(award_points.total, 0) AS points,
    solve_points.last_solved AS solved_at
FROM teams t
LEFT JOIN (
    SELECT s.team_id, SUM(c.points)::int AS points, MAX(s.solved_at) AS last_solved
    FROM solves s
    JOIN challenges c ON c.id = s.challenge_id
    WHERE s.solved_at <= $1
    GROUP BY s.team_id
) solve_points ON solve_points.team_id = t.id
LEFT JOIN (
    SELECT team_id, SUM(value)::int AS total
    FROM awards
    WHERE awards.created_at <= $2
    GROUP BY team_id
) award_points ON award_points.team_id = t.id
WHERE t.is_banned = false AND t.is_hidden = false AND t.deleted_at IS NULL
ORDER BY points DESC, COALESCE(solve_points.last_solved, '9999-12-31'::timestamp) ASC
`

type GetScoreboardFrozenParams struct {
	SolvedAt  *time.Time `json:"solved_at"`
	CreatedAt *time.Time `json:"created_at"`
}

type GetScoreboardFrozenRow struct {
	TeamID   uuid.UUID   `json:"team_id"`
	TeamName string      `json:"team_name"`
	Points   int32       `json:"points"`
	SolvedAt interface{} `json:"solved_at"`
}

func (q *Queries) GetScoreboardFrozen(ctx context.Context, arg GetScoreboardFrozenParams) ([]GetScoreboardFrozenRow, error) {
	rows, err := q.db.Query(ctx, getScoreboardFrozen, arg.SolvedAt, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScoreboardFrozenRow
	for rows.Next() {
		var i GetScoreboardFrozenRow
		if err := rows.Scan(
			&i.TeamID,
			&i.TeamName,
			&i.Points,
			&i.SolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSolveByID = `-- name: GetSolveByID :one
SELECT id, user_id, team_id, challenge_id, solved_at
FROM solves
WHERE id = $1
`

func (q *Queries) GetSolveByID(ctx context.Context, id uuid.UUID) (Solf, error) {
	row := q.db.QueryRow(ctx, getSolveByID, id)
	var i Solf
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.ChallengeID,
		&i.SolvedAt,
	)
	return i, err
}

const getSolveByTeamAndChallenge = `-- name: GetSolveByTeamAndChallenge :one
SELECT id, user_id, team_id, challenge_id, solved_at
FROM solves
WHERE team_id = $1 AND challenge_id = $2
`

type GetSolveByTeamAndChallengeParams struct {
	TeamID      uuid.UUID `json:"team_id"`
	ChallengeID uuid.UUID `json:"challenge_id"`
}

func (q *Queries) GetSolveByTeamAndChallenge(ctx context.Context, arg GetSolveByTeamAndChallengeParams) (Solf, error) {
	row := q.db.QueryRow(ctx, getSolveByTeamAndChallenge, arg.TeamID, arg.ChallengeID)
	var i Solf
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.ChallengeID,
		&i.SolvedAt,
	)
	return i, err
}

const getSolveByTeamAndChallengeForUpdate = `-- name: GetSolveByTeamAndChallengeForUpdate :one
SELECT id, user_id, team_id, challenge_id, solved_at
FROM solves
WHERE team_id = $1 AND challenge_id = $2
FOR UPDATE
`

type GetSolveByTeamAndChallengeForUpdateParams struct {
	TeamID      uuid.UUID `json:"team_id"`
	ChallengeID uuid.UUID `json:"challenge_id"`
}

func (q *Queries) GetSolveByTeamAndChallengeForUpdate(ctx context.Context, arg GetSolveByTeamAndChallengeForUpdateParams) (Solf, error) {
	row := q.db.QueryRow(ctx, getSolveByTeamAndChallengeForUpdate, arg.TeamID, arg.ChallengeID)
	var i Solf
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TeamID,
		&i.ChallengeID,
		&i.SolvedAt,
	)
	return i, err
}

const getSolvesByUserID = `-- name: GetSolvesByUserID :many
SELECT id, user_id, team_id, challenge_id, solved_at
FROM solves
WHERE user_id = $1
ORDER BY solved_at DESC
`

func (q *Queries) GetSolvesByUserID(ctx context.Context, userID uuid.UUID) ([]Solf, error) {
	rows, err := q.db.Query(ctx, getSolvesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Solf
	for rows.Next() {
		var i Solf
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TeamID,
			&i.ChallengeID,
			&i.SolvedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamScore = `-- name: GetTeamScore :one
SELECT
    COALESCE((
        SELECT SUM(c.points) FROM solves s
        JOIN challenges c ON c.id = s.challenge_id
        WHERE s.team_id = $1
    ), 0)::int +
    COALESCE((
        SELECT SUM(value) FROM awards WHERE team_id = $1
    ), 0)::int AS total
`

func (q *Queries) GetTeamScore(ctx context.Context, teamID uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getTeamScore, teamID)
	var total int32
	err := row.Scan(&total)
	return total, err
}
