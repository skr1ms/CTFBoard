// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: challenges.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const createChallenge = `-- name: CreateChallenge :exec
INSERT INTO challenges (id, title, description, category, points, initial_value, min_value, decay, solve_count, flag_hash, is_hidden, is_regex, is_case_insensitive, flag_regex, flag_format_regex)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
`

type CreateChallengeParams struct {
	ID                uuid.UUID `json:"id"`
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	Category          *string   `json:"category"`
	Points            *int32    `json:"points"`
	InitialValue      int32     `json:"initial_value"`
	MinValue          int32     `json:"min_value"`
	Decay             int32     `json:"decay"`
	SolveCount        int32     `json:"solve_count"`
	FlagHash          string    `json:"flag_hash"`
	IsHidden          *bool     `json:"is_hidden"`
	IsRegex           *bool     `json:"is_regex"`
	IsCaseInsensitive *bool     `json:"is_case_insensitive"`
	FlagRegex         *string   `json:"flag_regex"`
	FlagFormatRegex   *string   `json:"flag_format_regex"`
}

func (q *Queries) CreateChallenge(ctx context.Context, arg CreateChallengeParams) error {
	_, err := q.db.Exec(ctx, createChallenge,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Category,
		arg.Points,
		arg.InitialValue,
		arg.MinValue,
		arg.Decay,
		arg.SolveCount,
		arg.FlagHash,
		arg.IsHidden,
		arg.IsRegex,
		arg.IsCaseInsensitive,
		arg.FlagRegex,
		arg.FlagFormatRegex,
	)
	return err
}

const deleteChallenge = `-- name: DeleteChallenge :one
DELETE FROM challenges WHERE id = $1 RETURNING id
`

func (q *Queries) DeleteChallenge(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, deleteChallenge, id)
	err := row.Scan(&id)
	return id, err
}

const getChallengeByID = `-- name: GetChallengeByID :one
SELECT id, title, description, category, points, initial_value, min_value, decay, solve_count, flag_hash, is_hidden, is_regex, is_case_insensitive, flag_regex, flag_format_regex
FROM challenges
WHERE id = $1
`

type GetChallengeByIDRow struct {
	ID                uuid.UUID `json:"id"`
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	Category          *string   `json:"category"`
	Points            *int32    `json:"points"`
	InitialValue      int32     `json:"initial_value"`
	MinValue          int32     `json:"min_value"`
	Decay             int32     `json:"decay"`
	SolveCount        int32     `json:"solve_count"`
	FlagHash          string    `json:"flag_hash"`
	IsHidden          *bool     `json:"is_hidden"`
	IsRegex           *bool     `json:"is_regex"`
	IsCaseInsensitive *bool     `json:"is_case_insensitive"`
	FlagRegex         *string   `json:"flag_regex"`
	FlagFormatRegex   *string   `json:"flag_format_regex"`
}

func (q *Queries) GetChallengeByID(ctx context.Context, id uuid.UUID) (GetChallengeByIDRow, error) {
	row := q.db.QueryRow(ctx, getChallengeByID, id)
	var i GetChallengeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Category,
		&i.Points,
		&i.InitialValue,
		&i.MinValue,
		&i.Decay,
		&i.SolveCount,
		&i.FlagHash,
		&i.IsHidden,
		&i.IsRegex,
		&i.IsCaseInsensitive,
		&i.FlagRegex,
		&i.FlagFormatRegex,
	)
	return i, err
}

const getChallengeByIDForUpdate = `-- name: GetChallengeByIDForUpdate :one
SELECT id, title, description, category, points, initial_value, min_value, decay, solve_count, flag_hash, is_hidden, is_regex, is_case_insensitive, flag_regex, flag_format_regex
FROM challenges
WHERE id = $1
FOR UPDATE
`

type GetChallengeByIDForUpdateRow struct {
	ID                uuid.UUID `json:"id"`
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	Category          *string   `json:"category"`
	Points            *int32    `json:"points"`
	InitialValue      int32     `json:"initial_value"`
	MinValue          int32     `json:"min_value"`
	Decay             int32     `json:"decay"`
	SolveCount        int32     `json:"solve_count"`
	FlagHash          string    `json:"flag_hash"`
	IsHidden          *bool     `json:"is_hidden"`
	IsRegex           *bool     `json:"is_regex"`
	IsCaseInsensitive *bool     `json:"is_case_insensitive"`
	FlagRegex         *string   `json:"flag_regex"`
	FlagFormatRegex   *string   `json:"flag_format_regex"`
}

func (q *Queries) GetChallengeByIDForUpdate(ctx context.Context, id uuid.UUID) (GetChallengeByIDForUpdateRow, error) {
	row := q.db.QueryRow(ctx, getChallengeByIDForUpdate, id)
	var i GetChallengeByIDForUpdateRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Category,
		&i.Points,
		&i.InitialValue,
		&i.MinValue,
		&i.Decay,
		&i.SolveCount,
		&i.FlagHash,
		&i.IsHidden,
		&i.IsRegex,
		&i.IsCaseInsensitive,
		&i.FlagRegex,
		&i.FlagFormatRegex,
	)
	return i, err
}

const incrementChallengeSolveCount = `-- name: IncrementChallengeSolveCount :one
UPDATE challenges SET solve_count = solve_count + 1 WHERE id = $1 RETURNING solve_count
`

func (q *Queries) IncrementChallengeSolveCount(ctx context.Context, id uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, incrementChallengeSolveCount, id)
	var solve_count int32
	err := row.Scan(&solve_count)
	return solve_count, err
}

const listChallenges = `-- name: ListChallenges :many
SELECT c.id, c.title, c.description, c.category, c.points, c.initial_value, c.min_value, c.decay, c.solve_count, c.flag_hash, c.is_hidden, c.is_regex, c.is_case_insensitive, c.flag_regex, c.flag_format_regex, 0::int as solved
FROM challenges c
WHERE c.is_hidden = false
`

type ListChallengesRow struct {
	ID                uuid.UUID `json:"id"`
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	Category          *string   `json:"category"`
	Points            *int32    `json:"points"`
	InitialValue      int32     `json:"initial_value"`
	MinValue          int32     `json:"min_value"`
	Decay             int32     `json:"decay"`
	SolveCount        int32     `json:"solve_count"`
	FlagHash          string    `json:"flag_hash"`
	IsHidden          *bool     `json:"is_hidden"`
	IsRegex           *bool     `json:"is_regex"`
	IsCaseInsensitive *bool     `json:"is_case_insensitive"`
	FlagRegex         *string   `json:"flag_regex"`
	FlagFormatRegex   *string   `json:"flag_format_regex"`
	Solved            int32     `json:"solved"`
}

func (q *Queries) ListChallenges(ctx context.Context) ([]ListChallengesRow, error) {
	rows, err := q.db.Query(ctx, listChallenges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChallengesRow
	for rows.Next() {
		var i ListChallengesRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Category,
			&i.Points,
			&i.InitialValue,
			&i.MinValue,
			&i.Decay,
			&i.SolveCount,
			&i.FlagHash,
			&i.IsHidden,
			&i.IsRegex,
			&i.IsCaseInsensitive,
			&i.FlagRegex,
			&i.FlagFormatRegex,
			&i.Solved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChallengesByTag = `-- name: ListChallengesByTag :many
SELECT c.id, c.title, c.description, c.category, c.points, c.initial_value, c.min_value, c.decay, c.solve_count, c.flag_hash, c.is_hidden, c.is_regex, c.is_case_insensitive, c.flag_regex, c.flag_format_regex, 0::int as solved
FROM challenges c
JOIN challenge_tags ct ON ct.challenge_id = c.id AND ct.tag_id = $1
WHERE c.is_hidden = false
`

type ListChallengesByTagRow struct {
	ID                uuid.UUID `json:"id"`
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	Category          *string   `json:"category"`
	Points            *int32    `json:"points"`
	InitialValue      int32     `json:"initial_value"`
	MinValue          int32     `json:"min_value"`
	Decay             int32     `json:"decay"`
	SolveCount        int32     `json:"solve_count"`
	FlagHash          string    `json:"flag_hash"`
	IsHidden          *bool     `json:"is_hidden"`
	IsRegex           *bool     `json:"is_regex"`
	IsCaseInsensitive *bool     `json:"is_case_insensitive"`
	FlagRegex         *string   `json:"flag_regex"`
	FlagFormatRegex   *string   `json:"flag_format_regex"`
	Solved            int32     `json:"solved"`
}

func (q *Queries) ListChallengesByTag(ctx context.Context, tagID uuid.UUID) ([]ListChallengesByTagRow, error) {
	rows, err := q.db.Query(ctx, listChallengesByTag, tagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChallengesByTagRow
	for rows.Next() {
		var i ListChallengesByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Category,
			&i.Points,
			&i.InitialValue,
			&i.MinValue,
			&i.Decay,
			&i.SolveCount,
			&i.FlagHash,
			&i.IsHidden,
			&i.IsRegex,
			&i.IsCaseInsensitive,
			&i.FlagRegex,
			&i.FlagFormatRegex,
			&i.Solved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChallengesForTeam = `-- name: ListChallengesForTeam :many
SELECT c.id, c.title, c.description, c.category, c.points, c.initial_value, c.min_value, c.decay, c.solve_count, c.flag_hash, c.is_hidden, c.is_regex, c.is_case_insensitive, c.flag_regex, c.flag_format_regex,
    (CASE WHEN s.id IS NOT NULL THEN 1 ELSE 0 END)::int AS solved
FROM challenges c
LEFT JOIN solves s ON s.challenge_id = c.id AND s.team_id = $1
WHERE c.is_hidden = false
`

type ListChallengesForTeamRow struct {
	ID                uuid.UUID `json:"id"`
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	Category          *string   `json:"category"`
	Points            *int32    `json:"points"`
	InitialValue      int32     `json:"initial_value"`
	MinValue          int32     `json:"min_value"`
	Decay             int32     `json:"decay"`
	SolveCount        int32     `json:"solve_count"`
	FlagHash          string    `json:"flag_hash"`
	IsHidden          *bool     `json:"is_hidden"`
	IsRegex           *bool     `json:"is_regex"`
	IsCaseInsensitive *bool     `json:"is_case_insensitive"`
	FlagRegex         *string   `json:"flag_regex"`
	FlagFormatRegex   *string   `json:"flag_format_regex"`
	Solved            int32     `json:"solved"`
}

func (q *Queries) ListChallengesForTeam(ctx context.Context, teamID uuid.UUID) ([]ListChallengesForTeamRow, error) {
	rows, err := q.db.Query(ctx, listChallengesForTeam, teamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChallengesForTeamRow
	for rows.Next() {
		var i ListChallengesForTeamRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Category,
			&i.Points,
			&i.InitialValue,
			&i.MinValue,
			&i.Decay,
			&i.SolveCount,
			&i.FlagHash,
			&i.IsHidden,
			&i.IsRegex,
			&i.IsCaseInsensitive,
			&i.FlagRegex,
			&i.FlagFormatRegex,
			&i.Solved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listChallengesForTeamByTag = `-- name: ListChallengesForTeamByTag :many
SELECT c.id, c.title, c.description, c.category, c.points, c.initial_value, c.min_value, c.decay, c.solve_count, c.flag_hash, c.is_hidden, c.is_regex, c.is_case_insensitive, c.flag_regex, c.flag_format_regex,
    (CASE WHEN s.id IS NOT NULL THEN 1 ELSE 0 END)::int AS solved
FROM challenges c
JOIN challenge_tags ct ON ct.challenge_id = c.id AND ct.tag_id = $1
LEFT JOIN solves s ON s.challenge_id = c.id AND s.team_id = $2
WHERE c.is_hidden = false
`

type ListChallengesForTeamByTagParams struct {
	TagID  uuid.UUID `json:"tag_id"`
	TeamID uuid.UUID `json:"team_id"`
}

type ListChallengesForTeamByTagRow struct {
	ID                uuid.UUID `json:"id"`
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	Category          *string   `json:"category"`
	Points            *int32    `json:"points"`
	InitialValue      int32     `json:"initial_value"`
	MinValue          int32     `json:"min_value"`
	Decay             int32     `json:"decay"`
	SolveCount        int32     `json:"solve_count"`
	FlagHash          string    `json:"flag_hash"`
	IsHidden          *bool     `json:"is_hidden"`
	IsRegex           *bool     `json:"is_regex"`
	IsCaseInsensitive *bool     `json:"is_case_insensitive"`
	FlagRegex         *string   `json:"flag_regex"`
	FlagFormatRegex   *string   `json:"flag_format_regex"`
	Solved            int32     `json:"solved"`
}

func (q *Queries) ListChallengesForTeamByTag(ctx context.Context, arg ListChallengesForTeamByTagParams) ([]ListChallengesForTeamByTagRow, error) {
	rows, err := q.db.Query(ctx, listChallengesForTeamByTag, arg.TagID, arg.TeamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListChallengesForTeamByTagRow
	for rows.Next() {
		var i ListChallengesForTeamByTagRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Category,
			&i.Points,
			&i.InitialValue,
			&i.MinValue,
			&i.Decay,
			&i.SolveCount,
			&i.FlagHash,
			&i.IsHidden,
			&i.IsRegex,
			&i.IsCaseInsensitive,
			&i.FlagRegex,
			&i.FlagFormatRegex,
			&i.Solved,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChallenge = `-- name: UpdateChallenge :exec
UPDATE challenges SET
    title = $2, description = $3, category = $4, points = $5, initial_value = $6, min_value = $7,
    decay = $8, flag_hash = $9, is_hidden = $10, is_regex = $11, is_case_insensitive = $12, flag_regex = $13, flag_format_regex = $14
WHERE id = $1
`

type UpdateChallengeParams struct {
	ID                uuid.UUID `json:"id"`
	Title             string    `json:"title"`
	Description       string    `json:"description"`
	Category          *string   `json:"category"`
	Points            *int32    `json:"points"`
	InitialValue      int32     `json:"initial_value"`
	MinValue          int32     `json:"min_value"`
	Decay             int32     `json:"decay"`
	FlagHash          string    `json:"flag_hash"`
	IsHidden          *bool     `json:"is_hidden"`
	IsRegex           *bool     `json:"is_regex"`
	IsCaseInsensitive *bool     `json:"is_case_insensitive"`
	FlagRegex         *string   `json:"flag_regex"`
	FlagFormatRegex   *string   `json:"flag_format_regex"`
}

func (q *Queries) UpdateChallenge(ctx context.Context, arg UpdateChallengeParams) error {
	_, err := q.db.Exec(ctx, updateChallenge,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Category,
		arg.Points,
		arg.InitialValue,
		arg.MinValue,
		arg.Decay,
		arg.FlagHash,
		arg.IsHidden,
		arg.IsRegex,
		arg.IsCaseInsensitive,
		arg.FlagRegex,
		arg.FlagFormatRegex,
	)
	return err
}

const updateChallengePoints = `-- name: UpdateChallengePoints :one
UPDATE challenges SET points = $2 WHERE id = $1 RETURNING id
`

type UpdateChallengePointsParams struct {
	ID     uuid.UUID `json:"id"`
	Points *int32    `json:"points"`
}

func (q *Queries) UpdateChallengePoints(ctx context.Context, arg UpdateChallengePointsParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, updateChallengePoints, arg.ID, arg.Points)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}
