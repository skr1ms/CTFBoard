// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: teams.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const banTeam = `-- name: BanTeam :one
UPDATE teams SET is_banned = true, banned_at = $2, banned_reason = $3
WHERE id = $1 AND deleted_at IS NULL RETURNING id
`

type BanTeamParams struct {
	ID           uuid.UUID  `json:"id"`
	BannedAt     *time.Time `json:"banned_at"`
	BannedReason *string    `json:"banned_reason"`
}

func (q *Queries) BanTeam(ctx context.Context, arg BanTeamParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, banTeam, arg.ID, arg.BannedAt, arg.BannedReason)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const countTeamMembers = `-- name: CountTeamMembers :one
SELECT COUNT(*)::int FROM users WHERE team_id = $1
`

func (q *Queries) CountTeamMembers(ctx context.Context, teamID *uuid.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countTeamMembers, teamID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const createTeam = `-- name: CreateTeam :exec
INSERT INTO teams (id, name, invite_token, captain_id, is_solo, is_auto_created, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateTeamParams struct {
	ID            uuid.UUID  `json:"id"`
	Name          string     `json:"name"`
	InviteToken   uuid.UUID  `json:"invite_token"`
	CaptainID     uuid.UUID  `json:"captain_id"`
	IsSolo        *bool      `json:"is_solo"`
	IsAutoCreated *bool      `json:"is_auto_created"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) CreateTeam(ctx context.Context, arg CreateTeamParams) error {
	_, err := q.db.Exec(ctx, createTeam,
		arg.ID,
		arg.Name,
		arg.InviteToken,
		arg.CaptainID,
		arg.IsSolo,
		arg.IsAutoCreated,
		arg.CreatedAt,
	)
	return err
}

const createTeamReturningID = `-- name: CreateTeamReturningID :one
INSERT INTO teams (name, invite_token, captain_id, is_solo, is_auto_created, created_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateTeamReturningIDParams struct {
	Name          string     `json:"name"`
	InviteToken   uuid.UUID  `json:"invite_token"`
	CaptainID     uuid.UUID  `json:"captain_id"`
	IsSolo        *bool      `json:"is_solo"`
	IsAutoCreated *bool      `json:"is_auto_created"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) CreateTeamReturningID(ctx context.Context, arg CreateTeamReturningIDParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createTeamReturningID,
		arg.Name,
		arg.InviteToken,
		arg.CaptainID,
		arg.IsSolo,
		arg.IsAutoCreated,
		arg.CreatedAt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getAllTeams = `-- name: GetAllTeams :many
SELECT id, name, invite_token, captain_id, bracket_id, is_solo, is_auto_created, is_banned, banned_at, banned_reason, is_hidden, created_at
FROM teams
WHERE deleted_at IS NULL
ORDER BY created_at ASC
`

type GetAllTeamsRow struct {
	ID            uuid.UUID  `json:"id"`
	Name          string     `json:"name"`
	InviteToken   uuid.UUID  `json:"invite_token"`
	CaptainID     uuid.UUID  `json:"captain_id"`
	BracketID     *uuid.UUID `json:"bracket_id"`
	IsSolo        *bool      `json:"is_solo"`
	IsAutoCreated *bool      `json:"is_auto_created"`
	IsBanned      *bool      `json:"is_banned"`
	BannedAt      *time.Time `json:"banned_at"`
	BannedReason  *string    `json:"banned_reason"`
	IsHidden      *bool      `json:"is_hidden"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) GetAllTeams(ctx context.Context) ([]GetAllTeamsRow, error) {
	rows, err := q.db.Query(ctx, getAllTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllTeamsRow
	for rows.Next() {
		var i GetAllTeamsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.InviteToken,
			&i.CaptainID,
			&i.BracketID,
			&i.IsSolo,
			&i.IsAutoCreated,
			&i.IsBanned,
			&i.BannedAt,
			&i.BannedReason,
			&i.IsHidden,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSoloTeamByUserID = `-- name: GetSoloTeamByUserID :one
SELECT t.id, t.name, t.invite_token, t.captain_id, t.bracket_id, t.is_solo, t.is_auto_created, t.is_banned, t.banned_at, t.banned_reason, t.is_hidden, t.created_at
FROM teams t
JOIN users u ON u.team_id = t.id
WHERE u.id = $1 AND t.is_solo = true AND t.deleted_at IS NULL
`

type GetSoloTeamByUserIDRow struct {
	ID            uuid.UUID  `json:"id"`
	Name          string     `json:"name"`
	InviteToken   uuid.UUID  `json:"invite_token"`
	CaptainID     uuid.UUID  `json:"captain_id"`
	BracketID     *uuid.UUID `json:"bracket_id"`
	IsSolo        *bool      `json:"is_solo"`
	IsAutoCreated *bool      `json:"is_auto_created"`
	IsBanned      *bool      `json:"is_banned"`
	BannedAt      *time.Time `json:"banned_at"`
	BannedReason  *string    `json:"banned_reason"`
	IsHidden      *bool      `json:"is_hidden"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) GetSoloTeamByUserID(ctx context.Context, id uuid.UUID) (GetSoloTeamByUserIDRow, error) {
	row := q.db.QueryRow(ctx, getSoloTeamByUserID, id)
	var i GetSoloTeamByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.InviteToken,
		&i.CaptainID,
		&i.BracketID,
		&i.IsSolo,
		&i.IsAutoCreated,
		&i.IsBanned,
		&i.BannedAt,
		&i.BannedReason,
		&i.IsHidden,
		&i.CreatedAt,
	)
	return i, err
}

const getTeamByID = `-- name: GetTeamByID :one
SELECT id, name, invite_token, captain_id, bracket_id, is_solo, is_auto_created, is_banned, banned_at, banned_reason, is_hidden, created_at
FROM teams
WHERE id = $1 AND deleted_at IS NULL
`

type GetTeamByIDRow struct {
	ID            uuid.UUID  `json:"id"`
	Name          string     `json:"name"`
	InviteToken   uuid.UUID  `json:"invite_token"`
	CaptainID     uuid.UUID  `json:"captain_id"`
	BracketID     *uuid.UUID `json:"bracket_id"`
	IsSolo        *bool      `json:"is_solo"`
	IsAutoCreated *bool      `json:"is_auto_created"`
	IsBanned      *bool      `json:"is_banned"`
	BannedAt      *time.Time `json:"banned_at"`
	BannedReason  *string    `json:"banned_reason"`
	IsHidden      *bool      `json:"is_hidden"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) GetTeamByID(ctx context.Context, id uuid.UUID) (GetTeamByIDRow, error) {
	row := q.db.QueryRow(ctx, getTeamByID, id)
	var i GetTeamByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.InviteToken,
		&i.CaptainID,
		&i.BracketID,
		&i.IsSolo,
		&i.IsAutoCreated,
		&i.IsBanned,
		&i.BannedAt,
		&i.BannedReason,
		&i.IsHidden,
		&i.CreatedAt,
	)
	return i, err
}

const getTeamByInviteToken = `-- name: GetTeamByInviteToken :one
SELECT id, name, invite_token, captain_id, bracket_id, is_solo, is_auto_created, is_banned, banned_at, banned_reason, is_hidden, created_at
FROM teams
WHERE invite_token = $1 AND deleted_at IS NULL
`

type GetTeamByInviteTokenRow struct {
	ID            uuid.UUID  `json:"id"`
	Name          string     `json:"name"`
	InviteToken   uuid.UUID  `json:"invite_token"`
	CaptainID     uuid.UUID  `json:"captain_id"`
	BracketID     *uuid.UUID `json:"bracket_id"`
	IsSolo        *bool      `json:"is_solo"`
	IsAutoCreated *bool      `json:"is_auto_created"`
	IsBanned      *bool      `json:"is_banned"`
	BannedAt      *time.Time `json:"banned_at"`
	BannedReason  *string    `json:"banned_reason"`
	IsHidden      *bool      `json:"is_hidden"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) GetTeamByInviteToken(ctx context.Context, inviteToken uuid.UUID) (GetTeamByInviteTokenRow, error) {
	row := q.db.QueryRow(ctx, getTeamByInviteToken, inviteToken)
	var i GetTeamByInviteTokenRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.InviteToken,
		&i.CaptainID,
		&i.BracketID,
		&i.IsSolo,
		&i.IsAutoCreated,
		&i.IsBanned,
		&i.BannedAt,
		&i.BannedReason,
		&i.IsHidden,
		&i.CreatedAt,
	)
	return i, err
}

const getTeamByName = `-- name: GetTeamByName :one
SELECT id, name, invite_token, captain_id, bracket_id, is_solo, is_auto_created, is_banned, banned_at, banned_reason, is_hidden, created_at
FROM teams
WHERE name = $1 AND deleted_at IS NULL
`

type GetTeamByNameRow struct {
	ID            uuid.UUID  `json:"id"`
	Name          string     `json:"name"`
	InviteToken   uuid.UUID  `json:"invite_token"`
	CaptainID     uuid.UUID  `json:"captain_id"`
	BracketID     *uuid.UUID `json:"bracket_id"`
	IsSolo        *bool      `json:"is_solo"`
	IsAutoCreated *bool      `json:"is_auto_created"`
	IsBanned      *bool      `json:"is_banned"`
	BannedAt      *time.Time `json:"banned_at"`
	BannedReason  *string    `json:"banned_reason"`
	IsHidden      *bool      `json:"is_hidden"`
	CreatedAt     *time.Time `json:"created_at"`
}

func (q *Queries) GetTeamByName(ctx context.Context, name string) (GetTeamByNameRow, error) {
	row := q.db.QueryRow(ctx, getTeamByName, name)
	var i GetTeamByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.InviteToken,
		&i.CaptainID,
		&i.BracketID,
		&i.IsSolo,
		&i.IsAutoCreated,
		&i.IsBanned,
		&i.BannedAt,
		&i.BannedReason,
		&i.IsHidden,
		&i.CreatedAt,
	)
	return i, err
}

const hardDeleteTeamsBefore = `-- name: HardDeleteTeamsBefore :exec
DELETE FROM teams WHERE deleted_at IS NOT NULL AND deleted_at < $1
`

func (q *Queries) HardDeleteTeamsBefore(ctx context.Context, deletedAt *time.Time) error {
	_, err := q.db.Exec(ctx, hardDeleteTeamsBefore, deletedAt)
	return err
}

const setTeamBracket = `-- name: SetTeamBracket :one
UPDATE teams SET bracket_id = $2 WHERE id = $1 AND deleted_at IS NULL RETURNING id
`

type SetTeamBracketParams struct {
	ID        uuid.UUID  `json:"id"`
	BracketID *uuid.UUID `json:"bracket_id"`
}

func (q *Queries) SetTeamBracket(ctx context.Context, arg SetTeamBracketParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, setTeamBracket, arg.ID, arg.BracketID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const setTeamHidden = `-- name: SetTeamHidden :one
UPDATE teams SET is_hidden = $2 WHERE id = $1 AND deleted_at IS NULL RETURNING id
`

type SetTeamHiddenParams struct {
	ID       uuid.UUID `json:"id"`
	IsHidden *bool     `json:"is_hidden"`
}

func (q *Queries) SetTeamHidden(ctx context.Context, arg SetTeamHiddenParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, setTeamHidden, arg.ID, arg.IsHidden)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const softDeleteTeam = `-- name: SoftDeleteTeam :one
UPDATE teams SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL RETURNING id
`

func (q *Queries) SoftDeleteTeam(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, softDeleteTeam, id)
	err := row.Scan(&id)
	return id, err
}

const unbanTeam = `-- name: UnbanTeam :one
UPDATE teams SET is_banned = false, banned_at = NULL, banned_reason = NULL
WHERE id = $1 AND deleted_at IS NULL RETURNING id
`

func (q *Queries) UnbanTeam(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, unbanTeam, id)
	err := row.Scan(&id)
	return id, err
}

const updateTeamCaptain = `-- name: UpdateTeamCaptain :exec
UPDATE teams SET captain_id = $2 WHERE id = $1 AND deleted_at IS NULL
`

type UpdateTeamCaptainParams struct {
	ID        uuid.UUID `json:"id"`
	CaptainID uuid.UUID `json:"captain_id"`
}

func (q *Queries) UpdateTeamCaptain(ctx context.Context, arg UpdateTeamCaptainParams) error {
	_, err := q.db.Exec(ctx, updateTeamCaptain, arg.ID, arg.CaptainID)
	return err
}
